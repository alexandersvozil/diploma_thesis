\section{Definitions}

Before providing any content it is important that several definitions that
establish a firm basis are introduced. We will start out with the definition of a 
relational schema, database and conjunctive query. 

A relational name describes the name and arity of a relation.
\begin{definition}[Relational Schema]
	A relational schema is a nonempty finite set of relational names.
\end{definition}
Following up we have the definition of a database and relational atom over a
schema..

\begin{definition}[Database and relational atom]
	Let $\sigma$ be a relational schema, 
	$\U$ be an infinite set of constants and $X$ an infinite set of variables.
	A relational atom over $\sigma$ is an expression of the form $R(v)$ where $R$
	is a relational name in $\sigma$ and $v$ is an n-tuple over $\U \cup X$

	A database $D$ over $\sigma$ is a set of relational atoms without variables
	where each relational atom is over $\sigma$.
\end{definition}

After defining the meaning of a database and a schema we are ready to define
conjunctive queries.

\begin{definition}[Conjunctive Queries]
	Let $\sigma$ be a relational schema.
	A conjunctive query (CQ) $q$ over $\sigma$ is a rule of the form:
	\begin{align*}
		X \leftarrow R_1(\vec{v_1}), \dots, R_m(\vec{v_m}).
	\end{align*}
	Each $R_i(\vec{v_i}) (1\leq i \leq m)$ is a relational atom in $\sigma$ and 
	$X$ is a set of distinct variables among the ones that appear in the
	$\vec{v_i}$'s.
\end{definition}

It remains to define the semantics of a conjunctive query, i.e., how to evaluate
a query over a given database and schema.
\begin{definition}[Semantics of Conjunctive Queries]
	In order to evaluate a CQ given a database $D$ over a relational schema $\sigma$
	we need to define the semantics which is given in terms of homomorphisms.
	Let $D$ be a database over $\sigma$.  A homomorphism from a CQ $Q$ to $D$ is a
	partial mapping $h: X \rightarrow U$ such that $R_i(h(\vec{v_i})) \in D,$ for 
	$1 \leq i \leq m$. $h_{|X}$ is the restriction of $h$ to the variables in
	$X$. The evaluation $Q(D)$ is the set of all mappings of the form
	$h_{|X}$, such that $h$ is a homomorphism from $q$ to $D$.
\end{definition}

We will now define a simplified but absolutely (for our purposes) sufficient version of the
original formalisation of the RDF W3C-recommendation~\cite{rdf}:
URI stands for Uniform Resource Identifier and is a string used to identify
abstract and physical resources in the web.
The focus is on ground RDF graphs and we assume them to be composed of URIs only.

\begin{definition}[RDF]
	Let $\U$ is the infinite set of URIs. An RDF triple is a tuple in $\U \times \U \times \U$, whereas an
	RDF graph is a finite set of RDF triples. $dom(G) \subseteq \U$ of an RDF graph $G$ is the set of URIs actually appearing in $G$.
\end{definition}

RDF is the database and SPARQL will be our query language. To use SPARQL we need
to define the SPARQL syntax and semantics.

\begin{definition}[SPARQL SYNTAX]
	Again $\U$ is an infinite set of URIs. 
	$\V$ is an infinite set of variables with $\U \cap V = \emptyset$. 
	We will denote Variables in $\V$ with the letters $x,y,z,x',y',z',\dots$ and
	symbols which could be in $\V \cup \U$ with $u,v,w,u',v',w',\dots$.
	A SPARQL triple pattern is a tuple in  $(\U \cup \V) \times (\U \cup \V) \times (\U \cup \V)$. 
	SPARQL graph patterns are recursively defined as follows:
	\begin{enumerate}
		\item A triple pattern is a graph pattern.
		\item If $P_1$ and $P_2$ are graph patterns, then $(P_1  \ \circ \ P_2)$ for
			$\circ \in \{ AND, OPT, UNION\}$ is a graph pattern.
		\item If $P$ is a graph pattern and $a \in (I \cup V)$, then $(\mbox{GRAPH} \  a \ P)$ is a graph pattern.
		\item If $P$ is a graph pattern and $a \in (I \cup V)$, then $(\mbox{SERVICE} \  a \ P)$ is a graph pattern.
	\end{enumerate}
	\noindent Assuming $P$ is a graph pattern, $vars(P)$ denotes the set of variables occuring in $P$.
\end{definition}

We proceed in defining the semantics of SPARQL. 

\begin{definition}[SPARQL Semantics~\cite{pichler2014containment,
	builaranda20131}]
	A mapping is a function $\mu: A \rightarrow  \U$ for some $A \subset \V$. 
	For a triple pattern $t$ with $vars(t) \subseteq dom(\mu)$, we write $\mu(t)$ to 
	denote the triple after replacing the variables in $t$ by the corresponding 
	URIs according to $\mu$. 

	\noindent Two mappings $\mu_1$ and $\mu_2$ are called compatible (denoted $\mu_1 \sim \mu_2$) 
	if $\mu_1(?X) = \mu_2(?X)$ for all $?X \in dom(\mu_1) \cap dom(\mu_2)$.

	\noindent A mapping $\mu_1$ is subsumed by $\mu_2$ (written $\mu_1 \sqsubseteq \mu_2$) 
	if $\mu_1 \sim \mu_2$ and $dom(\mu_1) \subseteq dom(\mu_2)$. $\mu_2$ is then called ``extension'' of $\mu_1$.

	A dataset is a set $DS = \{(def, G), (g_1,G_1), \dots, (g_k, G_k) \}$, with
	$k\geq 0$ is a set of pairs of URIs and graphs,
	where the default graph $G$ is identified by the special symbol $def \notin \U$
	and the remaining so-called ``named'' graphs $(G_i)$ are identified by URIs
	$(g_i \in \U)$. We assume that any query is evaluated over a fixed dataset $DS$
	and that any SPARQL endpoint that is identified by an URI $c \in \U$ evaluates
	its queries against its own fixed dataset 
	$DS_c = \{ (def, G_c),(g_{c,1},G_{c,1}), \dots, (g_{c,k},G_{c,k})\}$.
	We assume a function $graph(g,DS)$ which, given a Dataset $DS$ and a graph name $g$ as
	input returns the graph corresponding to the symbol $g$. The function
	$names(DS)$ returns the set of names of the given dataset $DS$:
	$\{g_1,g_2,\dots,g_k\}$.
	We also assume a partial function $ep: \U \rightarrow DS$, such that for every $c \in
	\U$, if $ep(c)$ is defined, then $ep(c) = DS_c$, i.e., the dataset associated with
	the endpoint accessible via the URI c.
	$\mu_\emptyset$ denotes the mapping with empty domain. This means it is
	compatible with any other mapping.
	The evaluation of graph patterns over an RDF Graph $G$ is formalized as a
	function  $\llbracket \cdot \rrbracket_G^{DS}$, which, given a SPARQL graph pattern
	returns a set of mappings.
	For a graph pattern $P$, it is again defined recursively:
	\scalebox{0.64}{
		\vbox{
			\begin{enumerate}
				\item $\ll t \rr_G^{DS} = \{ \mu \ | \ dom(\mu) = vars(t) \mbox{ and } \mu(t)
					\in G \}$ for a triple pattern $t$.
				\item $\ll P_1 \ \mbox{AND} \ P_2 \rr_G^{DS} = \{ \mu_1 \cup \mu_2  \ | \ \mu_1 \in \ll P_1
					\rr_G^{DS},  \ \mu_2 \in \ll P_2 \rr_G^{DS} \mbox{ and } \mu_1 \sim \mu_2 \}$.
				\item $\ll P_1 \ \mbox{OPT} \ P_2 \rr_G^{DS} = \ll P_1 \ \mbox{AND} \ P_2 \rr_G^{DS}
					\cup \{ \mu_1 \in \ll P_1
					\rr_G^{DS} \ | \ \forall \mu_2 \in \ll P_2 \rr_G^{DS}: \mu_1 \not\sim \mu_2\}$.
				\item $\ll P_1 \ \mbox{UNION} \ P_2 \rr_G^{DS} = \ll P_1 \rr_G^{DS} \cup \ll P_2
					\rr_G^{DS}$.
				\item  $\ll \mbox{GRAPH } c \ P_1 \rr_G^{DS}  = 
					\begin{cases} 
						\ll P_1\rr_{graph(c,DS)}^{DS} &\mbox{if } c \in names(DS)\\	
						\{ \}						  & \mbox{if } c \in \U \backslash names(DS)\\
						\bigg\{\mu \cup [c \rightarrow s] \mid s \in names(DS), \mu
							\in \ll P_1 \rr^{DS}_{graph(s,DS)} \land [c \rightarrow s] \sim \mu
						\bigg\}						  & \mbox{if } c \in \V
						\end{cases}
						$\\ 
						for $c \in \U \cup \V$.

					\item $\ll \mbox{SERVICE } c \ P_1 \rr_G^{DS}  = 
						\begin{cases} 
							\ll P_1\rr_{graph(def,ep(c))}^{ep(c)} &\mbox{if } c \in dom(ep)\\	
							\{ \mu_\emptyset\} & \mbox{if } c \in \U \backslash dom(ep)\\
							\bigg\{\mu \cup [c \rightarrow s ] \mid s \in dom(ep), \mu
								\in \ll P_1 \rr^{ep(s)}_{graph(def,ep(s))} \land [ c \rightarrow s ] \sim \mu
							\bigg\}			   & \mbox{if } c \in \V
							\end{cases}$\\ 
							for $c \in \U \cup \V$.
					\end{enumerate}
				}
			}
		\end{definition}

		When we don't use the SERVICE or GRAPH operators and assume a graph $G$
		we will implicitly assume a dataset $DS = \{(def,G)\}$ and
		we will denote the evaluation function with $\ll \cdot \rr_G$ instead
		of $\ll \cdot \rr^{DS}_G$.

		We often use the term ``destination'' of a subquery containing the SERVICE or
		GRAPH operator in the top level.
		The destination refers to the URI or variable inbetween the graph
		pattern and the GRAPH or SERVICE operator.

		\begin{definition}[Destination of a SERVICE- or GRAPH-operator]
			Given a pattern $P$ of the form $P = (\mbox{SERVICE } u \ P_1)$ or
			$(P	= \mbox{GRAPH } u \ P_1)$ we call $u$ the
			destination of the pattern $P$.
		\end{definition}

		We will also define the fragment $P_{wdsg}$ which is crucial for proving the
		complexity results. $P_{wdsg}$ is a fragment which allows the arbitrary use of
		the GRAPH and SERVICE operator in any part of the query.
		\begin{definition}[$P_{wdsg}$]
			A pattern $Q \in P_{wdsg}$ if it adheres to the following grammar:
			\begin{align*}
				Q::= &  (Y \OPT R)  \mid B \\
				Y::= & (Y \AND Y) \mid (\mbox{SERVICE } u \ Y) \mid (\mbox{GRAPH } u \
				Y) \mid  B\\
				R::= &(R \OPT R) \mid (\mbox{GRAPH } u \ R) \mid (\mbox{SERVICE } u \ R) \mid B  \\
				B::= &(u,v,w)
			\end{align*}
			where	$u,v,w \in \U \cup \V$. In the first layer we seperate the pattern
			into an AND-part and an OPT-part. In the AND- and OPT-part we can use
			SERVICE and GRAPH freely.
		\end{definition}

		\section{Thoughts on the Semantics of the SERVICE and GRAPH Operator}
		We were introduced to the GRAPH and
		SERVICE operators by \cite{builaranda20131} where Buil-Aranda et al.
		describe the syntax and semantics of the SERVICE operator and how an efficient query
		evaluation system can be implemented. 
		Conversely to the semantic definition we provided, they provided the
		following definition for GRAPH (note the difference in the second case):	

		\scalebox{0.68}{
			\vbox{
				\begin{enumerate}
					\item  $\ll \mbox{GRAPH } c \ P_1 \rr_G^{DS}  = \begin{cases} 
							\ll P_1\rr_{graph(c,DS)}^{DS} &\mbox{if } c \in names(DS)\\	
							\{ \mu_{\emptyset}\} & \mbox{if } c \in \U \backslash names(DS)\\
							\bigg\{\mu \cup [c \rightarrow s ] \mid \exists s \in names(DS), \mu
								\in \ll P_1 \rr^{DS}_{graph(s,DS)} \land [ c \rightarrow s ] \sim \mu
							\bigg\} & \mbox{if } c \in \V
							\end{cases}$\\ for $c \in \U \cup \V$.
					\end{enumerate}
				}
			}

			We tried to propose an algorithm for evaluating CONTAINMENT[$S_1$,$S_2$] in the
			fragment $P_{wdgs}$ and we saw some unintuitive features regarding the semantics of the
			SERVICE and GRAPH operators. Consider the following example:
			\begin{example}
				$DS=\{(G_0,def), (G_1,a) \}$ where $G_0 = \{
				(c,k,g), (a,k,g) \}$, $G_1$ is arbitrary and  $Q = (GRAPH \ ?X  \ (GRAPH  \ c \  P_1)) \ AND \ (?X,k,g)$.
			\end{example}

			By evaluating the first part of the query, namely $\ll (GRAPH \ ?X  \ (GRAPH  \
			c \  P_1)) \rr$ where $P_1$ could be any arbitrary pattern, because $c \notin
			names(DS)$ and thus $\ll (GRAPH \ c  \ P_1) \rr = \mu_\emptyset$  we obtain $?X
			\rightarrow a$ ($\mu_\emptyset$ is compatible with every mapping). This is in
			our opinion unintuitive because it affects the rest of the query.
			If we would evaluate the right side of the $AND$ we would obtain the following: $\ll(?X,k,g)\rr = \{ (X \rightarrow a) , (X \rightarrow c) \}$ considering the
			left part of the $AND$-Operator we get the result of the query: $\{ (X \rightarrow a )
			\}$. Note that even though the graph with the URI $c$ does not exist and we are not able
			to evaluate pattern $P_1$ over it, we are able to somehow receive results using
			the $AND$ operator.
			\bigskip

			\noindent Considering containment/equivalence of two queries which just use the GRAPH
			Operator, there are specific instances where it is not obvious if one query is contained in the other query even though it should be intuitively.

			\begin{example}
				$Q_1$ = (GRAPH ?X ( GRAPH c ( GRAPH ?Y) $P_1$)),\\ 
				$Q_2$ = (GRAPH ?Y ( GRAPH c ( GRAPH ?X) $ P_1$))\\
				$?X,?Y \notin P_1$.
			\end{example}

			Approaching this example intuitively, one could say that $\ll Q_1 \rr = \ll Q_2
			\rr$ because $?X$ and $?Y$ get bound to every variable in the dataset because neither
			$?X$ nor $?Y$ occur in $P_1$, the triple pattern at the end
			of the query is the same and also the graph queried second is the same. 
			To show the opposite, just  consider the following dataset:
			$DS=\{(def,G_0), (a,G_1)\}$. Note that the URI $c$ does not occur in the dataset.
			But this means that $\ll Q_1 \rr^{DS}_G = \{?X \rightarrow a\}$ and  $\ll Q_2
			\rr^{DS}_G = \{?Y \rightarrow a\}$ rendering neither equivalence nor containment
			in any possible way.
			In \cite{builaranda20131} the authors
			state that the GRAPH-Operator was introduced formally
			in \cite{perez2009semantics} but we were not able to find the definition
			in it.
			Instead we tried to look into the W3C-recommendation\cite{w3standard} 
			where we found the following definition:
			\begin{lstlisting}
			if IRI is a graph name in D
			eval(D(G), Graph(IRI,P)) = eval(D(D[IRI]), P)
			if IRI is not a graph name in D
			eval(D(G), Graph(IRI,P)) = the empty multiset
			eval(D(G), Graph(var,P)) =
			Let R be the empty multiset
			foreach IRI i in D
			R := Union(R, Join( eval(D(D[i]), P) , $\Omega$(?var->i) )
			the result is R
			\end{lstlisting}

			If we look at the second case, we can see that the empty multiset (because the
			definition goes with bag semantics)
			is returned if the URI is not a graph name in the Dataset resulting
			in our original definition of SPARQL semantics. However the second
			case of the SERVICE-operator, i.e., $ if \c \in \U \backslash dom(ep)$ return
			$\mu_\emptyset$ stays the same and is intended by the authors in
			$\cite{builaranda20131}$.

			It's a bit unintuitive at first that if we have
			the third case (of both GRAPH and SERVIE), 
			namely $c \in \V$, the query $P_1$ will not be considered over the
			default graph. The reason for this can also be found in the definition of the
			dataset in the standard \cite{w3standard}:
			``A SPARQL query is executed against an RDF Dataset which represents a collection
			of graphs. An RDF Dataset comprises one graph, the default graph, which does not
			have a name, and zero or more named graphs, where each named graph is identified
			by an IRI. A SPARQL query can match different parts of the query pattern against
			different graphs as described in section 13.3 Querying the Dataset.''

